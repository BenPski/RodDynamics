<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>More Complex Material and Geometric Properties</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">More Complex Material and Geometric Properties</h1>
</header>
<p>$$ \newcommand{\real}{\mathbb{R}} \newcommand{\der}[2]{\frac{d#1}{d#2}} \newcommand{\pder}[2]{\frac{\partial#1}{\partial#2}} \newcommand{\D}[1]{\Delta#1} \newcommand{\inner}[2]{\langle#1, #2\rangle} $$</p>
<p></p>
<p>So far the considerations of the material properties and shape of the rod have been considered fairly simple. The rod is a cylinder, so its cross section is a constant circular shape, and the material is linear giving a simple form of the stiffness. Now there are many situations that would entail more complex considerations which we are going to look at now.</p>
<p>The primary place this considerations changes is the strain energy definition. So, now the energy will be defined in a more generic way as:</p>
<p><span class="math display">\[
U = \int u(\Delta\xi) dV
\]</span> where <span class="math inline">\(u\)</span> is the strain energy density function and therefore the strain energy is the integral of <span class="math inline">\(u\)</span> over the entire body.</p>
<p>Now we can start to look at how the variation of the strain energy, <span class="math inline">\(\delta U\)</span>, changes with a more general material model. We now get:</p>
<p><span class="math display">\[
\delta U = \inner{\delta h}{\int \nabla_{\D{\xi}} u dA} - \int \inner{\delta h}{ad_\xi^T(\int \nabla_{\D{\xi}} u dA) - \pder{}{s}(\int \nabla_{\D{\xi}} u dA)} ds
\]</span></p>
<p>For convenience we define: <span class="math display">\[
\Psi(s,\D{\xi}) = \int \nabla_{\D{\xi}} u dA
\]</span></p>
<p>If we make this substitution the strong form of the variation of the strain energy is:</p>
<p><span class="math display">\[
ad_\xi^T\Psi - \pder{}{s}\Psi
\]</span></p>
<p>Using the product rule we can expand this to:</p>
<p><span class="math display">\[
ad_\xi^T\Psi - \pder{\Psi}{\D{\xi}}\xi&#39; - \Psi&#39;
\]</span></p>
<p>So, in our original model we have <span class="math inline">\(\Psi = K\D{\xi}\)</span>. If we rearrange the dynamics equation to <span class="math inline">\(\xi&#39; = \dots\)</span> as needed by the simulation:</p>
<p><span class="math display">\[
\xi&#39; = (\pder{\Psi}{\D{\xi}} - \bar{A})^{-1}(M\dot{\eta} - ad_\eta^TM\eta + ad_\xi^T\Psi -\Psi&#39; + \bar{B})
\]</span></p>
<p>This shows that if we want to define more general material properties and geometric features we need to define <span class="math inline">\(\Psi\)</span>, <span class="math inline">\(\Psi&#39;\)</span>, and <span class="math inline">\(\pder{\Psi}{\D{\xi}}\)</span> to complete the dynamics.</p>
<p>While it would be nice to be able to separate the geometric and material properties in the simulations, in general that wonâ€™t be possible due to the definition of <span class="math inline">\(\Psi\)</span> depending on an integral over the cross sections. However, in certain forms we should be able to separate the definitions. So, we will look at some general definitions for the material and geometric properties and see when can we define special cases where the material and shape definitions can be separated.</p>
<p>For hyperelastic materials we can consider a general polynomial model of the material properties which is:</p>
<p><span class="math display">\[
u = \sum_{i,j=0} C_{ij}(I_1-3)^i(I_2-3)^j + \sum_{k=1} D_k(J-1)^{2k} 
\]</span> where <span class="math inline">\(C_{ij}\)</span> and <span class="math inline">\(D_k\)</span> are material constants determined empirically and <span class="math inline">\(I_1\)</span>, <span class="math inline">\(I_2\)</span>, and <span class="math inline">\(J\)</span> are invariants of <span class="math inline">\(F^TF\)</span> where <span class="math inline">\(F\)</span> is the deformation gradient. Also we assume <span class="math inline">\(C_{00} = 0\)</span> because the energy should be 0 with no deformation. In this case invariants means independent of coordinate rotations. Using the previously defined <span class="math inline">\(F\)</span> we get that the invariants are:</p>
<p><span class="math display">\[\begin{gather}
I_1 = (\nu_y + \omega_zr_xx)^2 + (\nu_x - \omega_zr_y)^2 + (\nu_z - \omega_yr_x + \omega_xr_y + 1)^2 + 2\\
I_2 = (\nu_y + \omega_zr_x)^2 + (\nu_x - \omega_zr_y)^2 + 2(\nu_z - \omega_yr_x + \omega_xr_y + 1)^2 + 1\\
J = \nu_z - \omega_yr_x + \omega_xr_y + 1\\
\end{gather}\]</span> where the components of <span class="math inline">\(\Delta\xi\)</span> have been broken up and the <span class="math inline">\(\Delta\)</span> dropped for simplicity, all the components are changes from the reference.</p>
<p>If we tried to do the symbolic manipulation to determine the form of <span class="math inline">\(\Psi\)</span> for arbitrary coefficients it does not appear possible and <span class="math inline">\(\Psi\)</span> would have to be determined for a specific case. However, if we restrict the polynomial for <span class="math inline">\(u\)</span> to only go upto a certain order then this could be possible.</p>
<p>Now we can start to implement the nonlinearity definitions into the system. First, we define the general interface for the body loads from <span class="math inline">\(\Psi\)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="kw">class</span> Body(metaclass<span class="op">=</span>ABCMeta):</a>
<a class="sourceLine" id="cb1-2" data-line-number="2">    <span class="co">&quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="co">    General interface for the body definition</span></a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="co">    </span></a>
<a class="sourceLine" id="cb1-5" data-line-number="5"><span class="co">    has to implement the values associated with the material and geometric parameters</span></a>
<a class="sourceLine" id="cb1-6" data-line-number="6"><span class="co">    Psi, Psi&#39;, and dPsi/dxi</span></a>
<a class="sourceLine" id="cb1-7" data-line-number="7"><span class="co">    &quot;&quot;&quot;</span></a>
<a class="sourceLine" id="cb1-8" data-line-number="8"></a>
<a class="sourceLine" id="cb1-9" data-line-number="9">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-10" data-line-number="10">    <span class="kw">def</span> Psi(<span class="va">self</span>, xi, s, rod):</a>
<a class="sourceLine" id="cb1-11" data-line-number="11">        <span class="cf">return</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])</a>
<a class="sourceLine" id="cb1-12" data-line-number="12"></a>
<a class="sourceLine" id="cb1-13" data-line-number="13">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-14" data-line-number="14">    <span class="kw">def</span> Psi_prime(<span class="va">self</span>, xi, s, rod):</a>
<a class="sourceLine" id="cb1-15" data-line-number="15">        <span class="cf">return</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])</a>
<a class="sourceLine" id="cb1-16" data-line-number="16"></a>
<a class="sourceLine" id="cb1-17" data-line-number="17">    <span class="at">@abstractmethod</span></a>
<a class="sourceLine" id="cb1-18" data-line-number="18">    <span class="kw">def</span> Psi_der(<span class="va">self</span>, xi, s, rod):</a>
<a class="sourceLine" id="cb1-19" data-line-number="19">        <span class="cf">return</span> np.zeros((<span class="dv">6</span>, <span class="dv">6</span>))</a></code></pre></div>
<p>Now the original rod needs to take a body argument and use the appropriate functions in the dynamics equation. However, it becomes apparent that the body should hold more information than just the wrench due to strain. It should define all the body dependent parameters like the inertia, <span class="math inline">\(M\)</span>, viscosity, and length, <span class="math inline">\(L\)</span>. So, the body should have more required information. Also, now the geometry is allowed to vary with <span class="math inline">\(s\)</span> and things are no longer just matrices so a few more change need to be made as well.</p>
<p>The first things to replace are the obvious parts in the rod dynamics and move them to the body definition. The body then includes inertia, viscosity, length, and <span class="math inline">\(\Psi\)</span> terms and the rod is defined by the body it is given rather than the material and geometric parameters. With no external loads these changes do not change the results of the simulations. However, with gravity we knew that it depends on both the density and the cross sectional area of the rods and we could pull that information from the rod definition, which is why the loads take the relevant rod as an argument, but now that information is not available and the gravitational load will not work correctly. To make gravity work again we have a few things to consider: we do not want to repeat ourselves when supplying data (i.e., define density once), gravity is a commonly used load but isnâ€™t always included, and want to keep all the interfaces pretty general. To rearrange how gravity is computed we need it to have access to the body definition and do not want to have to specify it for all systems. This makes gravity sit in a weird place it is most convenient to have it defined in the body as far as data goes, but we want it to be abstracted away from the body so if similar loads exist they can be defined similarly. So, gravity will have to access data from the body, but we do not want to need to define that data when gravity is not present as that just adds extra, unnecessary work. To deal with this gravity will try to call a method in the body to compute its needed values and this method will default to raising an unimplemented error this way it isnâ€™t absolutely necessary to make it work and it will alert the user when it needs to be defined. Seems like there could be a more abstracted way, but Iâ€™m not thinking of it or quite sure how Iâ€™d explain it in the first place, something like I want to keep the environment and the body cleanly separated, but gravity requires both and blurs the boundaries. Also, want the blurring of the boundaries to be generic which I havenâ€™t really achieved.</p>
<p>With the rambling out of the way, we have an interface for working with a body with generic material properties and shape. Now, since specific cases of the material properties can be handled in a generic way we can define a body with the material properties and geometry separate. The material case we look at is the polynomial model with only first order terms (I believe this is the incompressible Mooney-Rivlin model).</p>
<p><span class="math display">\[
u = C_1(I_1-3) + C_2(I_2-3)
\]</span></p>
<p>So, the material is fully defined by the coefficients <span class="math inline">\(C_1\)</span> and <span class="math inline">\(C_2\)</span>. If we go through the process of computing <span class="math inline">\(\Psi\)</span> we get:</p>
<p><span class="math display">\[
\Psi = \int \begin{bmatrix} 
                (2C_1+4C_2)x^2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; (2C_1+4C_2)y^2 &amp; 0 &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; (2C_1+2C_2)(x^2+y^2) &amp; 0 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 2C_1+2C_2 &amp; 0 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 2C_1+2C_2 &amp; 0 \\
                0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 2C_1+4C_2 \\
            \end{bmatrix}\Delta\xi dA
\]</span></p>
<p>Which can be simplified by substituting more familiar parameters <span class="math inline">\(E=2C_1+4C_2\)</span> and <span class="math inline">\(G=2C_1+2C_2\)</span>. So, we see two parameters similar to the elastic, <span class="math inline">\(E\)</span>, and shear, <span class="math inline">\(G\)</span>, modulus. Then integrating we get:</p>
<p><span class="math display">\[
\Psi = K\Delta\xi
\]</span> where <span class="math inline">\(K=\text{diag}([EI_x,EI_y,GJ,GA,GA,EA])\)</span>.</p>
<p>So, with the first order model we can easily define the body with the material and geometric properties decoupled. Implementing the same simulation as before works as expected.</p>
</body>
</html>
