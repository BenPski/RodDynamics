<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Integration: Conservative System</title>
  <style type="text/css">
      code{white-space: pre-wrap;}
      span.smallcaps{font-variant: small-caps;}
      span.underline{text-decoration: underline;}
      div.column{display: inline-block; vertical-align: top; width: 50%;}
  </style>
  <style type="text/css">
a.sourceLine { display: inline-block; line-height: 1.25; }
a.sourceLine { pointer-events: none; color: inherit; text-decoration: inherit; }
a.sourceLine:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
a.sourceLine { text-indent: -1em; padding-left: 1em; }
}
pre.numberSource a.sourceLine
  { position: relative; left: -4em; }
pre.numberSource a.sourceLine::before
  { content: attr(data-line-number);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; pointer-events: all; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {  }
@media screen {
a.sourceLine::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.2/MathJax.js?config=TeX-AMS_CHTML-full" type="text/javascript"></script>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">Integration: Conservative System</h1>
</header>
<p><span class="math display">\[
\newcommand{\D}[1]{\Delta#1}
\]</span></p>
<p>For the very initial introduction to the dynamics simulations I’ll be going over the simulation of a rod with no external loads and one end fixed to a wall. So, it will start in some initially bent configuration and then bend back and forth forever. This will also be a very specialized scheme to specifically this situation which will be built on later both for adding loads and for abstracting the scheme to be useful in other contexts.</p>
<h1 id="system">System</h1>
<p>First, the system of PDEs is: <span class="math display">\[\begin{gather}
    (M\dot{\eta} - ad_\eta^TM\eta) - (K\xi&#39; - ad_\xi^TK\D{\xi}) = 0 \\
    \dot{\xi} = \eta&#39; + ad_\xi\eta \\
    g&#39; = g\hat{\xi} \\
    \dot{g} = g\hat{\eta}
\end{gather}\]</span> with <span class="math inline">\(g(0) = I_{4\times4}\)</span> and <span class="math inline">\(\xi(L) = \xi^{*}\)</span> as the boundary conditions.</p>
<p>Now, there are no external loads so to get some dynamic behavior we have to include some initial bending which will be done by saying: <span class="math display">\[\begin{equation}
    \xi(t=0) = \begin{bmatrix} 0 \\ \alpha \\ 0 \\ 0 \\ 0 \\ 1 \end{bmatrix}
\end{equation}\]</span> where <span class="math inline">\(\alpha\)</span> will be set at different amounts and we have <span class="math inline">\(\xi^{*} = [0,0,0,0,0,1]^T\)</span>.</p>
<p>For the geometry of the rod we will have <span class="math inline">\(L\)</span>=10cm and <span class="math inline">\(D\)</span>=1cm and for the material properties we will have <span class="math inline">\(\rho=1000 g/cm^3\)</span>, <span class="math inline">\(E\)</span>=1MPa, and <span class="math inline">\(G=E/3\)</span>. This should specify all the necessary constants.</p>
<h1 id="discretization">Discretization</h1>
<p>For the discretization process first we discretize the PDEs implicitly in time to get ODEs in space. Then we discretize the ODEs explicitly in space to do the integration. For this we will be using the implicit midpoint rule to discretize in time (<span class="math inline">\(y_{i+1} = y_i + \D{t}\dot{y}_{i+1/2}\)</span>) and the explicit Euler in space (<span class="math inline">\(y_{i+1} = y_i + \D{s}y&#39;_i\)</span>). We will also use the RKMK versions for dealing with <span class="math inline">\(g\)</span>.</p>
<p>We first approximate the time derivatives implicitly: <span class="math display">\[\begin{gather}
    \dot{\xi}_{i+1/2} = \frac{1}{\D{t}}(\xi_{i+1}-\xi_i) \\
    \dot{\eta}_{i+1/2} = \frac{1}{\D{t}}(\eta_{i+1}-\eta_i)
\end{gather}\]</span> where the subscripts denote the time steps. It is important to notice the derivatives are at the half step, this will require a bit of extra work to make sure the stepping occurs on whole numbered time steps and may cause a little confusion at first.</p>
<p>So, now we can substitute the derivative approximations into the PDEs. When doing this we have to make sure the entire ODE is evaluated at the half step value to be consistent. <span class="math display">\[\begin{gather}
    \xi_{i+1/2}&#39; = K^{-1}(M(\frac{1}{\D{t}}(\eta_{i+1}-\eta_i)) - ad_{\eta_{i+1/2}}^TM\eta_{i+1/2} + ad_{\xi_{i+1/2}}^TK\D{\xi_{i+1/2}}) \\
    \eta_{i+1/2}&#39; = \frac{1}{\D{t}}(\xi_{i+1}-\xi_i) - ad_{\xi_{i+1/2}}\eta_{i+1/2}
\end{gather}\]</span> Now, we have ODEs in space that we can integrate with any explicit method we’d like, for simplicity we use the explicit Euler method. However, there are a few details that need to be worked out first in terms of dealing with the half steps and the boundary conditions.</p>
<p>In order to integrate <span class="math inline">\(\xi_{i+1/2}\)</span> and <span class="math inline">\(\eta_{i+1/2}\)</span> we need to know their initial values. For <span class="math inline">\(\eta\)</span> this is easy, we know the base is fixed and therefore <span class="math inline">\(\eta(s=0) = 0\)</span>. However, for <span class="math inline">\(\xi\)</span> we don’t know the initial condition only the final condition (<span class="math inline">\(\xi(s=L) = \xi^{*}\)</span>). This means we have a boundary value problem and we choose to approach this with a shooting method. A shooting method works by first guessing the unknown initial condition, integrating the system, and then checking if the boundary condition is met. If the condition is met the system is solved and if it is not met the guess for the initial condition is updated and the process repeated. So, we have to guess the initial condition for <span class="math inline">\(\xi_{i+1/2}\)</span>.</p>
<p>To deal with the half step values I choose to average the value between time steps: <span class="math display">\[\begin{gather}
    \xi_{i+1/2} = \frac{1}{2}(\xi_{i+1} + \xi_i) \\
    \eta_{i+1/2} = \frac{1}{2}(\eta_{i+1} + \eta_i)
\end{gather}\]</span></p>
<p>So, what we will really do is guess <span class="math inline">\(\xi_{i+1}\)</span> and use the integration and half step averaging to integrate the system.</p>
<p>For the stepping of <span class="math inline">\(g\)</span> we have both a space and time stepping, although due to the system being left-invariant (global rigid body displacements do not effect the physics) we only have to do the time stepping, but both are necessary later.</p>
<p>In space we have: <span class="math display">\[\begin{equation}
    g_{i+1/2}^{j+1} = g_{i+1/2}^j\exp(\D{s}\xi_{i+1/2}^j)
\end{equation}\]</span> where the superscipts denote the node in space.</p>
<p>In time we have: <span class="math display">\[\begin{equation}
    g_{i+1}^j = g_i^j\exp(\D{t}\eta_{i+1/2}^j)
\end{equation}\]</span></p>
<h1 id="implementation">Implementation</h1>
<h2 id="linear-algebra-imports">Linear Algebra Imports</h2>
<p>To start we need to import a some useful functions and numpy for doing the linear algebra.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb1-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb1-2" data-line-number="2"><span class="im">from</span> scipy.optimize <span class="im">import</span> fsolve</a>
<a class="sourceLine" id="cb1-3" data-line-number="3"><span class="im">from</span> scipy.linalg <span class="im">import</span> expm</a>
<a class="sourceLine" id="cb1-4" data-line-number="4"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a></code></pre></div>
<p><code>fsolve</code> is for the equation solving and <code>expm</code> is the matrix exponential.</p>
<h2 id="useful-functions">Useful Functions</h2>
<p>Then for the implementation we need a few useful functions for dealing with the different transformations between matrix and algebra forms.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb2-1" data-line-number="1"><span class="co"># map a vector to a skew symmetric matrix</span></a>
<a class="sourceLine" id="cb2-2" data-line-number="2"><span class="kw">def</span> skew(x):</a>
<a class="sourceLine" id="cb2-3" data-line-number="3">    <span class="cf">return</span> np.array([[<span class="dv">0</span>, <span class="op">-</span>x[<span class="dv">2</span>], x[<span class="dv">1</span>]], [x[<span class="dv">2</span>], <span class="dv">0</span>, <span class="op">-</span>x[<span class="dv">0</span>]], [<span class="op">-</span>x[<span class="dv">1</span>], x[<span class="dv">0</span>], <span class="dv">0</span>]])</a>
<a class="sourceLine" id="cb2-4" data-line-number="4"></a>
<a class="sourceLine" id="cb2-5" data-line-number="5"><span class="co"># map a twist to its adjoint form</span></a>
<a class="sourceLine" id="cb2-6" data-line-number="6"><span class="kw">def</span> adjoint(x):</a>
<a class="sourceLine" id="cb2-7" data-line-number="7">    <span class="cf">return</span> np.concatenate(</a>
<a class="sourceLine" id="cb2-8" data-line-number="8">        [np.concatenate([skew(x[:<span class="dv">3</span>]), np.zeros((<span class="dv">3</span>, <span class="dv">3</span>))], <span class="dv">1</span>), np.concatenate([skew(x[<span class="dv">3</span>:]), skew(x[:<span class="dv">3</span>])], <span class="dv">1</span>)])</a>
<a class="sourceLine" id="cb2-9" data-line-number="9"></a>
<a class="sourceLine" id="cb2-10" data-line-number="10"><span class="co"># flatten a homogeneous transformation matrix to a vector</span></a>
<a class="sourceLine" id="cb2-11" data-line-number="11"><span class="kw">def</span> flatten(g):</a>
<a class="sourceLine" id="cb2-12" data-line-number="12">    <span class="cf">return</span> np.concatenate([np.reshape(g[:<span class="dv">3</span>, :<span class="dv">3</span>], (<span class="dv">9</span>,)), g[:<span class="dv">3</span>, <span class="dv">3</span>]])</a>
<a class="sourceLine" id="cb2-13" data-line-number="13"></a>
<a class="sourceLine" id="cb2-14" data-line-number="14"><span class="co"># unflatten a homogeneous transformation</span></a>
<a class="sourceLine" id="cb2-15" data-line-number="15"><span class="kw">def</span> unflatten(g):</a>
<a class="sourceLine" id="cb2-16" data-line-number="16">    <span class="cf">return</span> np.row_stack((np.column_stack((np.reshape(g[:<span class="dv">9</span>], (<span class="dv">3</span>, <span class="dv">3</span>)), g[<span class="dv">9</span>:])), np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])))</a>
<a class="sourceLine" id="cb2-17" data-line-number="17"></a>
<a class="sourceLine" id="cb2-18" data-line-number="18"><span class="co"># the matrix representation of a twist vector</span></a>
<a class="sourceLine" id="cb2-19" data-line-number="19"><span class="kw">def</span> se(x):</a>
<a class="sourceLine" id="cb2-20" data-line-number="20">    <span class="cf">return</span> np.row_stack((np.column_stack((skew(x[:<span class="dv">3</span>]), x[<span class="dv">3</span>:])), np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])))</a></code></pre></div>
<p>These will provide the necessary manipulations for the arithmetic and the storage of values (specifically for <span class="math inline">\(g\)</span> with <code>flatten</code>).</p>
<h2 id="initial-conditions">Initial Conditions</h2>
<p>In order to actually run the simulations we need to initialize the state of the rod to begin the process. We will need the initial values for <span class="math inline">\(g\)</span>, <span class="math inline">\(\xi\)</span>, and <span class="math inline">\(\eta\)</span>. Since this case is just a rod bending back and forth we will start it in a bent position which is initially not moving. That means <span class="math inline">\(\eta=0\)</span> and for <span class="math inline">\(\xi\)</span> we can just select some constant value for each spatial point, here I picked <span class="math inline">\(\xi=[0, pi/(4*L), 0, 0, 0, 1]^T\)</span>. Determining <span class="math inline">\(g\)</span> can then be done with the explicit Euler RKMK. The only thing we will need to specify is the number of discretizations, <span class="math inline">\(N\)</span>, to use.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb3-1" data-line-number="1"><span class="kw">def</span> initRod(N):</a>
<a class="sourceLine" id="cb3-2" data-line-number="2">    L <span class="op">=</span> <span class="fl">10e-2</span> <span class="co"># length of the rod</span></a>
<a class="sourceLine" id="cb3-3" data-line-number="3"></a>
<a class="sourceLine" id="cb3-4" data-line-number="4">    g <span class="op">=</span> np.zeros((N, <span class="dv">12</span>))</a>
<a class="sourceLine" id="cb3-5" data-line-number="5">    xi <span class="op">=</span> np.repeat(np.array([[<span class="dv">0</span>, np.pi<span class="op">/</span><span class="dv">4</span><span class="op">/</span>L, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]]), N, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb3-6" data-line-number="6">    eta <span class="op">=</span> np.zeros((N, <span class="dv">6</span>))</a>
<a class="sourceLine" id="cb3-7" data-line-number="7">    </a>
<a class="sourceLine" id="cb3-8" data-line-number="8">    <span class="co">#explicit Euler RKMK</span></a>
<a class="sourceLine" id="cb3-9" data-line-number="9">    G <span class="op">=</span> np.eye(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb3-10" data-line-number="10">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb3-11" data-line-number="11">    g[<span class="dv">0</span>, :] <span class="op">=</span> flatten(G)</a>
<a class="sourceLine" id="cb3-12" data-line-number="12">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N):</a>
<a class="sourceLine" id="cb3-13" data-line-number="13">        G <span class="op">=</span> G <span class="op">@</span> expm(se(ds <span class="op">*</span> xi[i <span class="op">-</span> <span class="dv">1</span>, :]))</a>
<a class="sourceLine" id="cb3-14" data-line-number="14">        g[i, :] <span class="op">=</span> flatten(G)</a>
<a class="sourceLine" id="cb3-15" data-line-number="15"></a>
<a class="sourceLine" id="cb3-16" data-line-number="16">    <span class="cf">return</span> g, xi, eta</a></code></pre></div>
<p>This gives a pre-bent rod to start simulating. It should be noted that having to specify/hardcode <span class="math inline">\(L\)</span> is a bit inconvenient, so it’ll be something to address later. To check to see this works lets plot the rod to see if it makes sense. Note that technically the tip condition is not met given this initial configuration, but this shouldn’t be a problem.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb4-1" data-line-number="1"><span class="co"># start the figure</span></a>
<a class="sourceLine" id="cb4-2" data-line-number="2">fig, ax <span class="op">=</span> plt.subplots()</a>
<a class="sourceLine" id="cb4-3" data-line-number="3"><span class="co"># get the initial conditions</span></a>
<a class="sourceLine" id="cb4-4" data-line-number="4">g, xi, eta <span class="op">=</span> initRod(<span class="dv">100</span>)</a>
<a class="sourceLine" id="cb4-5" data-line-number="5"><span class="co"># make a 2D plot</span></a>
<a class="sourceLine" id="cb4-6" data-line-number="6">ax.plot(g[:,<span class="dv">9</span>], g[:,<span class="dv">11</span>])</a>
<a class="sourceLine" id="cb4-7" data-line-number="7"><span class="co"># make the axes equal</span></a>
<a class="sourceLine" id="cb4-8" data-line-number="8">ax.set_aspect(<span class="st">&#39;equal&#39;</span>)</a>
<a class="sourceLine" id="cb4-9" data-line-number="9"><span class="co"># show it</span></a>
<a class="sourceLine" id="cb4-10" data-line-number="10">plt.show()</a></code></pre></div>
<p>The resulting image is:</p>
<p><img src="init.png" title="Initial rod" /></p>
<p>Which seems like a sensible looking plot.</p>
<h2 id="integrator">Integrator</h2>
<p>For the integration there are several components. First, we are taking one time step into the future which constitutes solving the tip boundary condition and determining the initial condition for <span class="math inline">\(\xi(0)\)</span>. Then, once the system is solved it is integrated to determine the next state’s values. The functoin for this will look like:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb5-1" data-line-number="1"><span class="kw">def</span> step(g, xi, eta):</a>
<a class="sourceLine" id="cb5-2" data-line-number="2">    <span class="co"># determine xi0 by solving tip condition</span></a>
<a class="sourceLine" id="cb5-3" data-line-number="3">    xi0 <span class="op">=</span> fsolve(<span class="kw">lambda</span> x: condition(g, xi, eta, x), xi[<span class="dv">0</span>, :])</a>
<a class="sourceLine" id="cb5-4" data-line-number="4">    <span class="co"># integrate the system with the solved xi0</span></a>
<a class="sourceLine" id="cb5-5" data-line-number="5">    <span class="cf">return</span> integrate(g, xi, eta, xi0)</a></code></pre></div>
<p>We use the previous value for <span class="math inline">\(\xi(0)\)</span> as an initial guess because it should be be pretty close. Now we need to implement <code>condition</code> and <code>integrate</code>. For the condition we just need to integrate the system given the guess for <span class="math inline">\(\xi(0)\)</span> and then see if <span class="math inline">\(\xi(L) = \xi^{*}\)</span>.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb6-1" data-line-number="1"><span class="kw">def</span> condition(g, xi, eta, xi0):</a>
<a class="sourceLine" id="cb6-2" data-line-number="2">    g_next, xi_next, eta_next <span class="op">=</span> integrate(g, xi, eta, xi0)</a>
<a class="sourceLine" id="cb6-3" data-line-number="3">    <span class="cf">return</span> xi_next[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">-</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a></code></pre></div>
<p>Now we need to implement the integration scheme that uses implicit midpoint in time and the explicit Euler in space. This is a pretty mechanical process from the derivations and the result is:</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb7-1" data-line-number="1"><span class="kw">def</span> integrate(g, xi, eta, xi0):</a>
<a class="sourceLine" id="cb7-2" data-line-number="2">    <span class="co"># initialize empty matrices for storage</span></a>
<a class="sourceLine" id="cb7-3" data-line-number="3">    g_next <span class="op">=</span> np.zeros_like(g)</a>
<a class="sourceLine" id="cb7-4" data-line-number="4">    xi_next <span class="op">=</span> np.zeros_like(xi)</a>
<a class="sourceLine" id="cb7-5" data-line-number="5">    eta_next <span class="op">=</span> np.zeros_like(eta)</a>
<a class="sourceLine" id="cb7-6" data-line-number="6"></a>
<a class="sourceLine" id="cb7-7" data-line-number="7">    <span class="co"># determine number of spatial points, just believe everything is the right size</span></a>
<a class="sourceLine" id="cb7-8" data-line-number="8">    (N, _) <span class="op">=</span> xi.shape</a>
<a class="sourceLine" id="cb7-9" data-line-number="9">    </a>
<a class="sourceLine" id="cb7-10" data-line-number="10">    <span class="co"># set the guessed value</span></a>
<a class="sourceLine" id="cb7-11" data-line-number="11">    xi_next[<span class="dv">0</span>, :] <span class="op">=</span> xi0</a>
<a class="sourceLine" id="cb7-12" data-line-number="12">    </a>
<a class="sourceLine" id="cb7-13" data-line-number="13">    <span class="co"># material and geometric properties</span></a>
<a class="sourceLine" id="cb7-14" data-line-number="14">    xi_ref <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a>
<a class="sourceLine" id="cb7-15" data-line-number="15">    L <span class="op">=</span> <span class="fl">10e-2</span></a>
<a class="sourceLine" id="cb7-16" data-line-number="16">    D <span class="op">=</span> <span class="fl">1e-2</span></a>
<a class="sourceLine" id="cb7-17" data-line-number="17">    E <span class="op">=</span> <span class="fl">1e6</span></a>
<a class="sourceLine" id="cb7-18" data-line-number="18">    rho <span class="op">=</span> <span class="fl">1e3</span></a>
<a class="sourceLine" id="cb7-19" data-line-number="19">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb7-20" data-line-number="20">    dt <span class="op">=</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb7-21" data-line-number="21">    A <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">4</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb7-22" data-line-number="22">    I <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">64</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb7-23" data-line-number="23">    J <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> I</a>
<a class="sourceLine" id="cb7-24" data-line-number="24">    G <span class="op">=</span> E <span class="op">/</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb7-25" data-line-number="25">    K <span class="op">=</span> np.diag([E <span class="op">*</span> I, E <span class="op">*</span> I, G <span class="op">*</span> J, G <span class="op">*</span> A, G <span class="op">*</span> A, E <span class="op">*</span> A])</a>
<a class="sourceLine" id="cb7-26" data-line-number="26">    M <span class="op">=</span> rho <span class="op">*</span> np.diag([I, I, J, A, A, A])</a>
<a class="sourceLine" id="cb7-27" data-line-number="27"></a>
<a class="sourceLine" id="cb7-28" data-line-number="28">    <span class="co"># integration over the body (don&#39;t need the initial point as the initial values are determined already)</span></a>
<a class="sourceLine" id="cb7-29" data-line-number="29">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N <span class="op">-</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb7-30" data-line-number="30">        <span class="co"># averaging over steps to get half step values</span></a>
<a class="sourceLine" id="cb7-31" data-line-number="31">        xi_half <span class="op">=</span> (xi_next[i, :] <span class="op">+</span> xi[i, :]) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb7-32" data-line-number="32">        eta_half <span class="op">=</span> (eta_next[i, :] <span class="op">+</span> eta[i, :]) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb7-33" data-line-number="33">    </a>
<a class="sourceLine" id="cb7-34" data-line-number="34">        <span class="co"># implicit midpoint approximation</span></a>
<a class="sourceLine" id="cb7-35" data-line-number="35">        xi_dot <span class="op">=</span> (xi_next[i, :] <span class="op">-</span> xi[i, :]) <span class="op">/</span> dt</a>
<a class="sourceLine" id="cb7-36" data-line-number="36">        eta_dot <span class="op">=</span> (eta_next[i, :] <span class="op">-</span> eta[i, :]) <span class="op">/</span> dt</a>
<a class="sourceLine" id="cb7-37" data-line-number="37"></a>
<a class="sourceLine" id="cb7-38" data-line-number="38">        <span class="co"># spatial derivatives</span></a>
<a class="sourceLine" id="cb7-39" data-line-number="39">        xi_der <span class="op">=</span> np.linalg.inv(K) <span class="op">@</span> (</a>
<a class="sourceLine" id="cb7-40" data-line-number="40">                (M <span class="op">@</span> eta_dot) <span class="op">-</span> (adjoint(eta_half).T <span class="op">@</span> M <span class="op">@</span> eta_half) <span class="op">+</span> (adjoint(xi_half).T <span class="op">@</span> K <span class="op">@</span> (xi_half <span class="op">-</span> xi_ref)))</a>
<a class="sourceLine" id="cb7-41" data-line-number="41">        eta_der <span class="op">=</span> xi_dot <span class="op">-</span> (adjoint(xi_half) <span class="op">@</span> eta_half)</a>
<a class="sourceLine" id="cb7-42" data-line-number="42"></a>
<a class="sourceLine" id="cb7-43" data-line-number="43">        <span class="co"># explicit Euler step</span></a>
<a class="sourceLine" id="cb7-44" data-line-number="44">        xi_half_next <span class="op">=</span> xi_half <span class="op">+</span> ds <span class="op">*</span> xi_der</a>
<a class="sourceLine" id="cb7-45" data-line-number="45">        eta_half_next <span class="op">=</span> eta_half <span class="op">+</span> ds <span class="op">*</span> eta_der</a>
<a class="sourceLine" id="cb7-46" data-line-number="46"></a>
<a class="sourceLine" id="cb7-47" data-line-number="47">        <span class="co"># determine next step from half step value</span></a>
<a class="sourceLine" id="cb7-48" data-line-number="48">        xi_next[i <span class="op">+</span> <span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> xi_half_next <span class="op">-</span> xi[i<span class="op">+</span><span class="dv">1</span>, :]</a>
<a class="sourceLine" id="cb7-49" data-line-number="49">        eta_next[i <span class="op">+</span> <span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> eta_half_next <span class="op">-</span> eta[i<span class="op">+</span><span class="dv">1</span>, :]</a>
<a class="sourceLine" id="cb7-50" data-line-number="50"></a>
<a class="sourceLine" id="cb7-51" data-line-number="51">    <span class="co"># midpoint RKMK to step the g values</span></a>
<a class="sourceLine" id="cb7-52" data-line-number="52">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</a>
<a class="sourceLine" id="cb7-53" data-line-number="53">        g_next[i, :] <span class="op">=</span> flatten(unflatten(g[i,:]) <span class="op">@</span> expm(se(dt <span class="op">*</span> (eta_next[i,:] <span class="op">+</span> eta[i,:])<span class="op">/</span><span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb7-54" data-line-number="54"></a>
<a class="sourceLine" id="cb7-55" data-line-number="55">    <span class="cf">return</span> g_next, xi_next, eta_next</a></code></pre></div>
<p>This fully defines the integrator. We can see that specifying the material properties and such in the integrator is a bit wasteful, every iteration the data gets allocated and freed even though it never changes and it is inconvenient to update. Both of these will be addressed later.</p>
<p>To get an initial glance at how well this performs we run several steps of the dynamics to see how it looks.</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb8-1" data-line-number="1"><span class="kw">def</span> plotDynamics(N, steps):</a>
<a class="sourceLine" id="cb8-2" data-line-number="2">    <span class="co"># start figure</span></a>
<a class="sourceLine" id="cb8-3" data-line-number="3">    fig, ax <span class="op">=</span> plt.subplots()</a>
<a class="sourceLine" id="cb8-4" data-line-number="4">    g, xi, eta <span class="op">=</span> initRod(N)</a>
<a class="sourceLine" id="cb8-5" data-line-number="5">    ax.plot(g[:,<span class="dv">9</span>], g[:,<span class="dv">11</span>])</a>
<a class="sourceLine" id="cb8-6" data-line-number="6">    ax.set_aspect(<span class="st">&#39;equal&#39;</span>)</a>
<a class="sourceLine" id="cb8-7" data-line-number="7">    plt.pause(<span class="fl">0.01</span>) <span class="co"># make the plots show up as they&#39;re updated</span></a>
<a class="sourceLine" id="cb8-8" data-line-number="8"></a>
<a class="sourceLine" id="cb8-9" data-line-number="9">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</a>
<a class="sourceLine" id="cb8-10" data-line-number="10">        g, xi, eta <span class="op">=</span> step(g, xi, eta)</a>
<a class="sourceLine" id="cb8-11" data-line-number="11">        ax.plot(g[:,<span class="dv">9</span>], g[:,<span class="dv">11</span>])</a>
<a class="sourceLine" id="cb8-12" data-line-number="12">        plt.pause(<span class="fl">0.01</span>) <span class="co"># make the plots show up as they&#39;re updated</span></a>
<a class="sourceLine" id="cb8-13" data-line-number="13">    </a>
<a class="sourceLine" id="cb8-14" data-line-number="14">    <span class="co">#make sure it stays open for looking at and saving</span></a>
<a class="sourceLine" id="cb8-15" data-line-number="15">    plt.show()</a></code></pre></div>
<p>Running <code>plotDynamics(100, 20)</code> we get:</p>
<p><img src="dynamics.png" title="Dynamics simulation" /></p>
<p>Which wobbles back and forth as expected.</p>
<p>Now we want to see if it is actually energy preserving as claimed. For this we want to approximate the energy in the system which is just summing the kinetic and strain energy over the whole body. We do this as:</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb9-1" data-line-number="1"><span class="kw">def</span> energy(xi,eta):</a>
<a class="sourceLine" id="cb9-2" data-line-number="2">    <span class="co"># similar to the setup for the integrator</span></a>
<a class="sourceLine" id="cb9-3" data-line-number="3">    (N, _) <span class="op">=</span> xi.shape</a>
<a class="sourceLine" id="cb9-4" data-line-number="4">    xi_ref <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a>
<a class="sourceLine" id="cb9-5" data-line-number="5">    L <span class="op">=</span> <span class="fl">10e-2</span></a>
<a class="sourceLine" id="cb9-6" data-line-number="6">    D <span class="op">=</span> <span class="fl">1e-2</span></a>
<a class="sourceLine" id="cb9-7" data-line-number="7">    E <span class="op">=</span> <span class="fl">1e6</span></a>
<a class="sourceLine" id="cb9-8" data-line-number="8">    rho <span class="op">=</span> <span class="fl">1e3</span></a>
<a class="sourceLine" id="cb9-9" data-line-number="9">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb9-10" data-line-number="10">    dt <span class="op">=</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb9-11" data-line-number="11">    A <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">4</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb9-12" data-line-number="12">    I <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">64</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb9-13" data-line-number="13">    J <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> I</a>
<a class="sourceLine" id="cb9-14" data-line-number="14">    G <span class="op">=</span> E <span class="op">/</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb9-15" data-line-number="15">    K <span class="op">=</span> np.diag([E <span class="op">*</span> I, E <span class="op">*</span> I, G <span class="op">*</span> J, G <span class="op">*</span> A, G <span class="op">*</span> A, E <span class="op">*</span> A])</a>
<a class="sourceLine" id="cb9-16" data-line-number="16">    M <span class="op">=</span> rho <span class="op">*</span> np.diag([I, I, J, A, A, A])</a>
<a class="sourceLine" id="cb9-17" data-line-number="17"></a>
<a class="sourceLine" id="cb9-18" data-line-number="18">    H <span class="op">=</span> <span class="dv">0</span> <span class="co"># total energy</span></a>
<a class="sourceLine" id="cb9-19" data-line-number="19">    </a>
<a class="sourceLine" id="cb9-20" data-line-number="20">    <span class="co"># integrate over the rod</span></a>
<a class="sourceLine" id="cb9-21" data-line-number="21">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</a>
<a class="sourceLine" id="cb9-22" data-line-number="22">        T <span class="op">=</span> eta[i,:].T <span class="op">@</span> M <span class="op">@</span> eta[i,:]</a>
<a class="sourceLine" id="cb9-23" data-line-number="23">        U <span class="op">=</span> (xi[i,:]<span class="op">-</span>xi_ref).T <span class="op">@</span> K <span class="op">@</span> (xi[i,:]<span class="op">-</span>xi_ref)</a>
<a class="sourceLine" id="cb9-24" data-line-number="24">        H <span class="op">+=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>(T <span class="op">+</span> U)</a>
<a class="sourceLine" id="cb9-25" data-line-number="25">    <span class="cf">return</span> ds<span class="op">*</span>H <span class="co">#multiply by discrete step size to scale</span></a></code></pre></div>
<p>Then running several steps of the dynamics and recording the energy:</p>
<div class="sourceCode" id="cb10"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb10-1" data-line-number="1"><span class="kw">def</span> plotEnergy(N, steps):</a>
<a class="sourceLine" id="cb10-2" data-line-number="2">    fig, ax <span class="op">=</span> plt.subplots()</a>
<a class="sourceLine" id="cb10-3" data-line-number="3">    g, xi, eta <span class="op">=</span> initRod(N)</a>
<a class="sourceLine" id="cb10-4" data-line-number="4">    E <span class="op">=</span> []</a>
<a class="sourceLine" id="cb10-5" data-line-number="5"></a>
<a class="sourceLine" id="cb10-6" data-line-number="6">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</a>
<a class="sourceLine" id="cb10-7" data-line-number="7">        g, xi, eta <span class="op">=</span> step(g, xi, eta)</a>
<a class="sourceLine" id="cb10-8" data-line-number="8">        E.append(energy(xi,eta))</a>
<a class="sourceLine" id="cb10-9" data-line-number="9"></a>
<a class="sourceLine" id="cb10-10" data-line-number="10">    ax.plot(E)</a>
<a class="sourceLine" id="cb10-11" data-line-number="11">    plt.show()</a></code></pre></div>
<p>Running <code>plotEnergy(100, 100)</code> we get:</p>
<p><img src="energy.png" title="Energy trace" /></p>
<p>Here we see that there is oscillation of the energy; however, it is rather small and due to numerical precision. The energy continues to oscillate around the same point over a long time indicating the energy is preserved.</p>
<p>It is worth trying the simulations with different numbers of spatial points and lenths of time steps. You should see instability isues when the time step and the number of spatial points are small.</p>
<p>The full code is posted below and in conservative.py</p>
<div class="sourceCode" id="cb11"><pre class="sourceCode python"><code class="sourceCode python"><a class="sourceLine" id="cb11-1" data-line-number="1"><span class="im">import</span> numpy <span class="im">as</span> np</a>
<a class="sourceLine" id="cb11-2" data-line-number="2"><span class="im">from</span> scipy.optimize <span class="im">import</span> fsolve</a>
<a class="sourceLine" id="cb11-3" data-line-number="3"><span class="im">from</span> scipy.linalg <span class="im">import</span> expm</a>
<a class="sourceLine" id="cb11-4" data-line-number="4"><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</a>
<a class="sourceLine" id="cb11-5" data-line-number="5"></a>
<a class="sourceLine" id="cb11-6" data-line-number="6"><span class="co"># Some utilities</span></a>
<a class="sourceLine" id="cb11-7" data-line-number="7"><span class="co"># map a vector to a skew symmetric matrix</span></a>
<a class="sourceLine" id="cb11-8" data-line-number="8"><span class="kw">def</span> skew(x):</a>
<a class="sourceLine" id="cb11-9" data-line-number="9">    <span class="cf">return</span> np.array([[<span class="dv">0</span>, <span class="op">-</span>x[<span class="dv">2</span>], x[<span class="dv">1</span>]], [x[<span class="dv">2</span>], <span class="dv">0</span>, <span class="op">-</span>x[<span class="dv">0</span>]], [<span class="op">-</span>x[<span class="dv">1</span>], x[<span class="dv">0</span>], <span class="dv">0</span>]])</a>
<a class="sourceLine" id="cb11-10" data-line-number="10"></a>
<a class="sourceLine" id="cb11-11" data-line-number="11"><span class="co"># map a twist to its adjoint form</span></a>
<a class="sourceLine" id="cb11-12" data-line-number="12"><span class="kw">def</span> adjoint(x):</a>
<a class="sourceLine" id="cb11-13" data-line-number="13">    <span class="cf">return</span> np.concatenate(</a>
<a class="sourceLine" id="cb11-14" data-line-number="14">        [np.concatenate([skew(x[:<span class="dv">3</span>]), np.zeros((<span class="dv">3</span>, <span class="dv">3</span>))], <span class="dv">1</span>), np.concatenate([skew(x[<span class="dv">3</span>:]), skew(x[:<span class="dv">3</span>])], <span class="dv">1</span>)])</a>
<a class="sourceLine" id="cb11-15" data-line-number="15"></a>
<a class="sourceLine" id="cb11-16" data-line-number="16"><span class="co"># flatten a homogeneous transformation matrix to a vector</span></a>
<a class="sourceLine" id="cb11-17" data-line-number="17"><span class="kw">def</span> flatten(g):</a>
<a class="sourceLine" id="cb11-18" data-line-number="18">    <span class="cf">return</span> np.concatenate([np.reshape(g[:<span class="dv">3</span>, :<span class="dv">3</span>], (<span class="dv">9</span>,)), g[:<span class="dv">3</span>, <span class="dv">3</span>]])</a>
<a class="sourceLine" id="cb11-19" data-line-number="19"></a>
<a class="sourceLine" id="cb11-20" data-line-number="20"><span class="co"># unflatten a homogeneous transformation</span></a>
<a class="sourceLine" id="cb11-21" data-line-number="21"><span class="kw">def</span> unflatten(g):</a>
<a class="sourceLine" id="cb11-22" data-line-number="22">    <span class="cf">return</span> np.row_stack((np.column_stack((np.reshape(g[:<span class="dv">9</span>], (<span class="dv">3</span>, <span class="dv">3</span>)), g[<span class="dv">9</span>:])), np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])))</a>
<a class="sourceLine" id="cb11-23" data-line-number="23"></a>
<a class="sourceLine" id="cb11-24" data-line-number="24"><span class="co"># the matrix representation of a twist vector</span></a>
<a class="sourceLine" id="cb11-25" data-line-number="25"><span class="kw">def</span> se(x):</a>
<a class="sourceLine" id="cb11-26" data-line-number="26">    <span class="cf">return</span> np.row_stack((np.column_stack((skew(x[:<span class="dv">3</span>]), x[<span class="dv">3</span>:])), np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>])))</a>
<a class="sourceLine" id="cb11-27" data-line-number="27"></a>
<a class="sourceLine" id="cb11-28" data-line-number="28"></a>
<a class="sourceLine" id="cb11-29" data-line-number="29"><span class="co"># Initialization</span></a>
<a class="sourceLine" id="cb11-30" data-line-number="30"><span class="kw">def</span> initRod(N):</a>
<a class="sourceLine" id="cb11-31" data-line-number="31">    L <span class="op">=</span> <span class="fl">10e-2</span> <span class="co"># length of the rod</span></a>
<a class="sourceLine" id="cb11-32" data-line-number="32"></a>
<a class="sourceLine" id="cb11-33" data-line-number="33">    g <span class="op">=</span> np.zeros((N, <span class="dv">12</span>))</a>
<a class="sourceLine" id="cb11-34" data-line-number="34">    xi <span class="op">=</span> np.repeat(np.array([[<span class="dv">0</span>, np.pi<span class="op">/</span><span class="dv">4</span><span class="op">/</span>L, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>]]), N, <span class="dv">0</span>)</a>
<a class="sourceLine" id="cb11-35" data-line-number="35">    eta <span class="op">=</span> np.zeros((N, <span class="dv">6</span>))</a>
<a class="sourceLine" id="cb11-36" data-line-number="36">    </a>
<a class="sourceLine" id="cb11-37" data-line-number="37">    <span class="co">#explicit Euler RKMK</span></a>
<a class="sourceLine" id="cb11-38" data-line-number="38">    G <span class="op">=</span> np.eye(<span class="dv">4</span>)</a>
<a class="sourceLine" id="cb11-39" data-line-number="39">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-40" data-line-number="40">    g[<span class="dv">0</span>, :] <span class="op">=</span> flatten(G)</a>
<a class="sourceLine" id="cb11-41" data-line-number="41">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, N):</a>
<a class="sourceLine" id="cb11-42" data-line-number="42">        G <span class="op">=</span> G <span class="op">@</span> expm(se(ds <span class="op">*</span> xi[i <span class="op">-</span> <span class="dv">1</span>, :]))</a>
<a class="sourceLine" id="cb11-43" data-line-number="43">        g[i, :] <span class="op">=</span> flatten(G)</a>
<a class="sourceLine" id="cb11-44" data-line-number="44"></a>
<a class="sourceLine" id="cb11-45" data-line-number="45">    <span class="cf">return</span> g, xi, eta</a>
<a class="sourceLine" id="cb11-46" data-line-number="46"></a>
<a class="sourceLine" id="cb11-47" data-line-number="47"><span class="co">#Integration</span></a>
<a class="sourceLine" id="cb11-48" data-line-number="48"><span class="kw">def</span> step(g, xi, eta):</a>
<a class="sourceLine" id="cb11-49" data-line-number="49">    <span class="co"># determine xi0 by solving tip condition</span></a>
<a class="sourceLine" id="cb11-50" data-line-number="50">    xi0 <span class="op">=</span> fsolve(<span class="kw">lambda</span> x: condition(g, xi, eta, x), xi[<span class="dv">0</span>, :])</a>
<a class="sourceLine" id="cb11-51" data-line-number="51">    <span class="co"># integrate the system with the solved xi0</span></a>
<a class="sourceLine" id="cb11-52" data-line-number="52">    <span class="cf">return</span> integrate(g, xi, eta, xi0)</a>
<a class="sourceLine" id="cb11-53" data-line-number="53"></a>
<a class="sourceLine" id="cb11-54" data-line-number="54"><span class="kw">def</span> condition(g, xi, eta, xi0):</a>
<a class="sourceLine" id="cb11-55" data-line-number="55">    g_next, xi_next, eta_next <span class="op">=</span> integrate(g, xi, eta, xi0)</a>
<a class="sourceLine" id="cb11-56" data-line-number="56">    <span class="cf">return</span> xi_next[<span class="op">-</span><span class="dv">1</span>, :] <span class="op">-</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a>
<a class="sourceLine" id="cb11-57" data-line-number="57"></a>
<a class="sourceLine" id="cb11-58" data-line-number="58"><span class="kw">def</span> integrate(g, xi, eta, xi0):</a>
<a class="sourceLine" id="cb11-59" data-line-number="59">    <span class="co"># initialize empty matrices for storage</span></a>
<a class="sourceLine" id="cb11-60" data-line-number="60">    g_next <span class="op">=</span> np.zeros_like(g)</a>
<a class="sourceLine" id="cb11-61" data-line-number="61">    xi_next <span class="op">=</span> np.zeros_like(xi)</a>
<a class="sourceLine" id="cb11-62" data-line-number="62">    eta_next <span class="op">=</span> np.zeros_like(eta)</a>
<a class="sourceLine" id="cb11-63" data-line-number="63"></a>
<a class="sourceLine" id="cb11-64" data-line-number="64">    <span class="co"># determine number of spatial points, just believe everything is the right size</span></a>
<a class="sourceLine" id="cb11-65" data-line-number="65">    (N, _) <span class="op">=</span> xi.shape</a>
<a class="sourceLine" id="cb11-66" data-line-number="66">    </a>
<a class="sourceLine" id="cb11-67" data-line-number="67">    <span class="co"># set the guessed value</span></a>
<a class="sourceLine" id="cb11-68" data-line-number="68">    xi_next[<span class="dv">0</span>, :] <span class="op">=</span> xi0</a>
<a class="sourceLine" id="cb11-69" data-line-number="69">    </a>
<a class="sourceLine" id="cb11-70" data-line-number="70">    <span class="co"># material and geometric properties</span></a>
<a class="sourceLine" id="cb11-71" data-line-number="71">    xi_ref <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a>
<a class="sourceLine" id="cb11-72" data-line-number="72">    L <span class="op">=</span> <span class="fl">10e-2</span></a>
<a class="sourceLine" id="cb11-73" data-line-number="73">    D <span class="op">=</span> <span class="fl">1e-2</span></a>
<a class="sourceLine" id="cb11-74" data-line-number="74">    E <span class="op">=</span> <span class="fl">1e6</span></a>
<a class="sourceLine" id="cb11-75" data-line-number="75">    rho <span class="op">=</span> <span class="fl">1e3</span></a>
<a class="sourceLine" id="cb11-76" data-line-number="76">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-77" data-line-number="77">    dt <span class="op">=</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb11-78" data-line-number="78">    A <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">4</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb11-79" data-line-number="79">    I <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">64</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb11-80" data-line-number="80">    J <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> I</a>
<a class="sourceLine" id="cb11-81" data-line-number="81">    G <span class="op">=</span> E <span class="op">/</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb11-82" data-line-number="82">    K <span class="op">=</span> np.diag([E <span class="op">*</span> I, E <span class="op">*</span> I, G <span class="op">*</span> J, G <span class="op">*</span> A, G <span class="op">*</span> A, E <span class="op">*</span> A])</a>
<a class="sourceLine" id="cb11-83" data-line-number="83">    M <span class="op">=</span> rho <span class="op">*</span> np.diag([I, I, J, A, A, A])</a>
<a class="sourceLine" id="cb11-84" data-line-number="84"></a>
<a class="sourceLine" id="cb11-85" data-line-number="85">    <span class="co"># integration over the body (don&#39;t need the initial point as the initial values are determined already)</span></a>
<a class="sourceLine" id="cb11-86" data-line-number="86">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N <span class="op">-</span> <span class="dv">1</span>):</a>
<a class="sourceLine" id="cb11-87" data-line-number="87">        <span class="co"># averaging over steps to get half step values</span></a>
<a class="sourceLine" id="cb11-88" data-line-number="88">        xi_half <span class="op">=</span> (xi_next[i, :] <span class="op">+</span> xi[i, :]) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb11-89" data-line-number="89">        eta_half <span class="op">=</span> (eta_next[i, :] <span class="op">+</span> eta[i, :]) <span class="op">/</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb11-90" data-line-number="90">    </a>
<a class="sourceLine" id="cb11-91" data-line-number="91">        <span class="co"># implicit midpoint approximation</span></a>
<a class="sourceLine" id="cb11-92" data-line-number="92">        xi_dot <span class="op">=</span> (xi_next[i, :] <span class="op">-</span> xi[i, :]) <span class="op">/</span> dt</a>
<a class="sourceLine" id="cb11-93" data-line-number="93">        eta_dot <span class="op">=</span> (eta_next[i, :] <span class="op">-</span> eta[i, :]) <span class="op">/</span> dt</a>
<a class="sourceLine" id="cb11-94" data-line-number="94"></a>
<a class="sourceLine" id="cb11-95" data-line-number="95">        <span class="co"># spatial derivatives</span></a>
<a class="sourceLine" id="cb11-96" data-line-number="96">        xi_der <span class="op">=</span> np.linalg.inv(K) <span class="op">@</span> (</a>
<a class="sourceLine" id="cb11-97" data-line-number="97">                (M <span class="op">@</span> eta_dot) <span class="op">-</span> (adjoint(eta_half).T <span class="op">@</span> M <span class="op">@</span> eta_half) <span class="op">+</span> (adjoint(xi_half).T <span class="op">@</span> K <span class="op">@</span> (xi_half <span class="op">-</span> xi_ref)))</a>
<a class="sourceLine" id="cb11-98" data-line-number="98">        eta_der <span class="op">=</span> xi_dot <span class="op">-</span> (adjoint(xi_half) <span class="op">@</span> eta_half)</a>
<a class="sourceLine" id="cb11-99" data-line-number="99"></a>
<a class="sourceLine" id="cb11-100" data-line-number="100">        <span class="co"># explicit Euler step</span></a>
<a class="sourceLine" id="cb11-101" data-line-number="101">        xi_half_next <span class="op">=</span> xi_half <span class="op">+</span> ds <span class="op">*</span> xi_der</a>
<a class="sourceLine" id="cb11-102" data-line-number="102">        eta_half_next <span class="op">=</span> eta_half <span class="op">+</span> ds <span class="op">*</span> eta_der</a>
<a class="sourceLine" id="cb11-103" data-line-number="103"></a>
<a class="sourceLine" id="cb11-104" data-line-number="104">        <span class="co"># determine next step from half step value</span></a>
<a class="sourceLine" id="cb11-105" data-line-number="105">        xi_next[i <span class="op">+</span> <span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> xi_half_next <span class="op">-</span> xi[i<span class="op">+</span><span class="dv">1</span>, :]</a>
<a class="sourceLine" id="cb11-106" data-line-number="106">        eta_next[i <span class="op">+</span> <span class="dv">1</span>, :] <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> eta_half_next <span class="op">-</span> eta[i<span class="op">+</span><span class="dv">1</span>, :]</a>
<a class="sourceLine" id="cb11-107" data-line-number="107"></a>
<a class="sourceLine" id="cb11-108" data-line-number="108">    <span class="co"># midpoint RKMK to step the g values</span></a>
<a class="sourceLine" id="cb11-109" data-line-number="109">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</a>
<a class="sourceLine" id="cb11-110" data-line-number="110">        g_next[i, :] <span class="op">=</span> flatten(unflatten(g[i,:]) <span class="op">@</span> expm(se(dt <span class="op">*</span> (eta_next[i,:] <span class="op">+</span> eta[i,:])<span class="op">/</span><span class="dv">2</span>)))</a>
<a class="sourceLine" id="cb11-111" data-line-number="111"></a>
<a class="sourceLine" id="cb11-112" data-line-number="112">    <span class="cf">return</span> g_next, xi_next, eta_next</a>
<a class="sourceLine" id="cb11-113" data-line-number="113"></a>
<a class="sourceLine" id="cb11-114" data-line-number="114"></a>
<a class="sourceLine" id="cb11-115" data-line-number="115"><span class="co"># Testing functions</span></a>
<a class="sourceLine" id="cb11-116" data-line-number="116"><span class="kw">def</span> plotDynamics(N, steps):</a>
<a class="sourceLine" id="cb11-117" data-line-number="117">    <span class="co"># start figure</span></a>
<a class="sourceLine" id="cb11-118" data-line-number="118">    fig, ax <span class="op">=</span> plt.subplots()</a>
<a class="sourceLine" id="cb11-119" data-line-number="119">    g, xi, eta <span class="op">=</span> initRod(N)</a>
<a class="sourceLine" id="cb11-120" data-line-number="120">    ax.plot(g[:,<span class="dv">9</span>], g[:,<span class="dv">11</span>])</a>
<a class="sourceLine" id="cb11-121" data-line-number="121">    ax.set_aspect(<span class="st">&#39;equal&#39;</span>)</a>
<a class="sourceLine" id="cb11-122" data-line-number="122">    plt.pause(<span class="fl">0.01</span>) <span class="co"># make the plots show up as they&#39;re updated</span></a>
<a class="sourceLine" id="cb11-123" data-line-number="123"></a>
<a class="sourceLine" id="cb11-124" data-line-number="124">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</a>
<a class="sourceLine" id="cb11-125" data-line-number="125">        g, xi, eta <span class="op">=</span> step(g, xi, eta)</a>
<a class="sourceLine" id="cb11-126" data-line-number="126">        ax.plot(g[:,<span class="dv">9</span>], g[:,<span class="dv">11</span>])</a>
<a class="sourceLine" id="cb11-127" data-line-number="127">        plt.pause(<span class="fl">0.01</span>) <span class="co"># make the plots show up as they&#39;re updated</span></a>
<a class="sourceLine" id="cb11-128" data-line-number="128">    </a>
<a class="sourceLine" id="cb11-129" data-line-number="129">    <span class="co">#make sure it stays open for looking at and saving</span></a>
<a class="sourceLine" id="cb11-130" data-line-number="130">    plt.show()</a>
<a class="sourceLine" id="cb11-131" data-line-number="131"></a>
<a class="sourceLine" id="cb11-132" data-line-number="132"><span class="kw">def</span> energy(xi,eta):</a>
<a class="sourceLine" id="cb11-133" data-line-number="133">    <span class="co"># similar to the setup for the integrator</span></a>
<a class="sourceLine" id="cb11-134" data-line-number="134">    (N, _) <span class="op">=</span> xi.shape</a>
<a class="sourceLine" id="cb11-135" data-line-number="135">    xi_ref <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>])</a>
<a class="sourceLine" id="cb11-136" data-line-number="136">    L <span class="op">=</span> <span class="fl">10e-2</span></a>
<a class="sourceLine" id="cb11-137" data-line-number="137">    D <span class="op">=</span> <span class="fl">1e-2</span></a>
<a class="sourceLine" id="cb11-138" data-line-number="138">    E <span class="op">=</span> <span class="fl">1e6</span></a>
<a class="sourceLine" id="cb11-139" data-line-number="139">    rho <span class="op">=</span> <span class="fl">1e3</span></a>
<a class="sourceLine" id="cb11-140" data-line-number="140">    ds <span class="op">=</span> L <span class="op">/</span> (N <span class="op">-</span> <span class="dv">1</span>)</a>
<a class="sourceLine" id="cb11-141" data-line-number="141">    dt <span class="op">=</span> <span class="fl">0.01</span></a>
<a class="sourceLine" id="cb11-142" data-line-number="142">    A <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">4</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">2</span></a>
<a class="sourceLine" id="cb11-143" data-line-number="143">    I <span class="op">=</span> np.pi <span class="op">/</span> <span class="dv">64</span> <span class="op">*</span> D <span class="op">**</span> <span class="dv">4</span></a>
<a class="sourceLine" id="cb11-144" data-line-number="144">    J <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span> I</a>
<a class="sourceLine" id="cb11-145" data-line-number="145">    G <span class="op">=</span> E <span class="op">/</span> <span class="dv">3</span></a>
<a class="sourceLine" id="cb11-146" data-line-number="146">    K <span class="op">=</span> np.diag([E <span class="op">*</span> I, E <span class="op">*</span> I, G <span class="op">*</span> J, G <span class="op">*</span> A, G <span class="op">*</span> A, E <span class="op">*</span> A])</a>
<a class="sourceLine" id="cb11-147" data-line-number="147">    M <span class="op">=</span> rho <span class="op">*</span> np.diag([I, I, J, A, A, A])</a>
<a class="sourceLine" id="cb11-148" data-line-number="148"></a>
<a class="sourceLine" id="cb11-149" data-line-number="149">    H <span class="op">=</span> <span class="dv">0</span> <span class="co"># total energy</span></a>
<a class="sourceLine" id="cb11-150" data-line-number="150">    </a>
<a class="sourceLine" id="cb11-151" data-line-number="151">    <span class="co"># integrate over the rod</span></a>
<a class="sourceLine" id="cb11-152" data-line-number="152">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N):</a>
<a class="sourceLine" id="cb11-153" data-line-number="153">        T <span class="op">=</span> eta[i,:].T <span class="op">@</span> M <span class="op">@</span> eta[i,:]</a>
<a class="sourceLine" id="cb11-154" data-line-number="154">        U <span class="op">=</span> (xi[i,:]<span class="op">-</span>xi_ref).T <span class="op">@</span> K <span class="op">@</span> (xi[i,:]<span class="op">-</span>xi_ref)</a>
<a class="sourceLine" id="cb11-155" data-line-number="155">        H <span class="op">+=</span> <span class="dv">1</span><span class="op">/</span><span class="dv">2</span><span class="op">*</span>(T <span class="op">+</span> U)</a>
<a class="sourceLine" id="cb11-156" data-line-number="156">    <span class="cf">return</span> ds<span class="op">*</span>H <span class="co">#multiply by discrete step size to scale</span></a>
<a class="sourceLine" id="cb11-157" data-line-number="157"></a>
<a class="sourceLine" id="cb11-158" data-line-number="158"><span class="kw">def</span> plotEnergy(N, steps):</a>
<a class="sourceLine" id="cb11-159" data-line-number="159">    fig, ax <span class="op">=</span> plt.subplots()</a>
<a class="sourceLine" id="cb11-160" data-line-number="160">    g, xi, eta <span class="op">=</span> initRod(N)</a>
<a class="sourceLine" id="cb11-161" data-line-number="161">    E <span class="op">=</span> []</a>
<a class="sourceLine" id="cb11-162" data-line-number="162"></a>
<a class="sourceLine" id="cb11-163" data-line-number="163">    <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(steps):</a>
<a class="sourceLine" id="cb11-164" data-line-number="164">        g, xi, eta <span class="op">=</span> step(g, xi, eta)</a>
<a class="sourceLine" id="cb11-165" data-line-number="165">        E.append(energy(xi,eta))</a>
<a class="sourceLine" id="cb11-166" data-line-number="166"></a>
<a class="sourceLine" id="cb11-167" data-line-number="167">    ax.plot(E)</a>
<a class="sourceLine" id="cb11-168" data-line-number="168">    plt.show()</a>
<a class="sourceLine" id="cb11-169" data-line-number="169"></a>
<a class="sourceLine" id="cb11-170" data-line-number="170"><span class="co"># Call the script as python conservative.py</span></a>
<a class="sourceLine" id="cb11-171" data-line-number="171"><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</a>
<a class="sourceLine" id="cb11-172" data-line-number="172">    <span class="co"># plotDynamics(100, 20)</span></a>
<a class="sourceLine" id="cb11-173" data-line-number="173">    plotEnergy(<span class="dv">100</span>,<span class="dv">100</span>)</a></code></pre></div>
</body>
</html>
